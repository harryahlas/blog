---
title: Multi-Condition Data Retrieval
author: Harry Ahlas
date: '2019-07-21'
slug: multi-condition-data-retrieval
categories: []
tags: []
---



<div id="use-r-and-sql-to-circumvent-technology-limitations-on-large-queries-with-2-or-more-conditions" class="section level2">
<h2>Use R and SQL to Circumvent Technology Limitations on Large Queries with 2 or more Conditions</h2>
<p>Sometimes standard business intelligence tools can fail when clients ask for complex data wrangling the tools are not built to retrieve. One people analytics example I have run into is when a client wants to know information about employees as of specific dates.</p>
<p>On occasion, seemingly simple business questions like this can be challenging if systems are built for single-condition queries. Typically, clients may come with a spreadsheet like the one below, where one condition changes - different employee numbers - but the other columns do not change.</p>
<div class="figure">
<img src="/post/2020-01-24-multi-condition-data-retrieval_files/easy_retrieval.gif" alt="Easy retrieval" />
<p class="caption">Easy retrieval</p>
</div>
<p>In this case, if the client wants information about these employees on that date, such as their job titles, it’s no problem, a very simple data pull.</p>
<p>However, on occasion clients ask for information about different employees on different dates, like in this spreadsheet where the dates are <em>different</em> on each row:</p>
<div class="figure">
<img src="/post/2020-01-24-multi-condition-data-retrieval_files/difficult_retrieval.gif" alt="More challenging retrieval" />
<p class="caption">More challenging retrieval</p>
</div>
<p>Now we have two conditions that can change. This second condition - multiple dates - adds a layer of complexity that some BI systems cannot handle. We are required to hand code each condition. Yuck! This limitation, as well as others, becomes glaring when clients ask for larger amounts of data, say 50,000 rows.</p>
<p>I have more information about these BI tool limitations and why I have chosen this solution <a href="/post/2020-01-24-multi-condition-data-retrieval_files/2019-07-21-multi-condition-data-retrieval-challenges.html">here</a>.</p>
<p>In this post we will circumvent the limitations of our standard BI tools to make multi-condition data retrieval easier. We will:</p>
<ul>
<li>Import data</li>
<li>Connect to an SQL database</li>
<li>Create an SQL query with special placeholders</li>
<li>Run the SQL query iteratively</li>
<li>Export data</li>
</ul>
<p>I want to be clear that the following methodology is not for everyone. This process meets the need in my environment and I thought I would share in the hope that some of you will benefit from this information.</p>
<p>The raw R script is <a href="https://github.com/harryahlas/sample-hr-database/blob/master/analysis/multi_condition_data_retrieval.R">here</a>.</p>
<div id="client-data" class="section level3">
<h3>Client Data</h3>
<p>For our example, we’ll say a client wants to know the job titles a set of employees had on some sort of incident or notification date. We’ll start with Excel to see the file the client has provided. <a href="https://raw.githubusercontent.com/harryahlas/sample-hr-database/master/data/JohnsonLitigationResearch.xlsx">Here</a> is a link to the file and here is a screengrab:</p>
<div class="figure">
<img src="/post/2020-01-24-multi-condition-data-retrieval_files/client_input.gif" alt="File from client that needs additional data (yellow highlight)" />
<p class="caption">File from client that needs additional data (yellow highlight)</p>
</div>
<p>The client has privided us with a list of employee numbers and dates and asked us to populate the <code>Job Name</code> field. Column C, <code>Role in incident</code>, is irrelevant to our data pull but the client wants us to include it in the final file we provide.</p>
<p>Let’s move to R and and import our data using the <em>readxl</em> package. We’ll load the other libraries we’ll need as well. Since the sample client Excel file is stored on GitHub, we can use the <em>httr</em> package to download and write it to disk in a temp file. Then we can import with readxl’s <code>read_excel</code> function.</p>
<pre class="r"><code>library(tidyverse)
library(openxlsx)
library(readxl)
library(httr)

temp_file &lt;- tempfile(fileext = &quot;.xlsx&quot;)
req &lt;- GET(&quot;https://raw.githubusercontent.com/harryahlas/sample-hr-database/master/data/JohnsonLitigationResearch.xlsx&quot;, 
           # write result to disk
           write_disk(path = temp_file))
input_data &lt;- read_excel(temp_file)</code></pre>
<p>We can remove the <code>Job Name</code> field since we will be replacing it. Additionally, let’s update the date field to a date format. This will help with joins later.</p>
<pre class="r"><code>input_data &lt;- input_data %&gt;% 
  select(-`Job Name`) %&gt;% 
  mutate(`Date of incident or notification` = 
    as.Date(`Date of incident or notification`))</code></pre>
</div>
<div id="the-hr-sample-database-and-connecting-to-r" class="section level3">
<h3>The HR Sample Database and Connecting to R</h3>
<p>The job title data the client is interested in is available in the <em>hrsample</em> database. For the purpose of this exercise, we’ll access the <em>hrsample</em> data via an SQLite3 database.
The <em>hrsample</em> R package has a function to automatically install the data to an SQLite database via the <em>RSQLite</em> package. More detailed instructions on how to install SQLite are here if needed.</p>
<pre class="r"><code>devtools::install_github(&quot;harryahlas/hrsample&quot;)
library(hrsample)
hrsampleCreateSQLite(&quot;my_db.sqlite3&quot;)</code></pre>
<p>We can connect using <em>RSQLite</em> and take a look at the tables available:</p>
<pre class="r"><code>con &lt;- dbConnect(RSQLite::SQLite(), 
    &#39;my_db.sqlite3&#39;)
                      
dbListTables(con)
 [1] &quot;contact_table&quot;     &quot;deskhistory&quot;       &quot;deskjob&quot;           &quot;education_table&quot;   &quot;employeeinfo&quot;     
 [6] &quot;hierarchy&quot;         &quot;performancereview&quot; &quot;recruiting_table&quot;  &quot;rollup_view&quot;       &quot;salaryhistory&quot;    
[11] &quot;skills_table&quot; </code></pre>
<p>The <code>deskhistory</code> and <code>desk_id</code> tables have what we need. The <code>deskhistory</code> table has a history of employee positions (desk_ids) in the company, showing who sat where at what time. The <code>deskjob</code> table shows what job belongs to each <code>desk_id.</code> We can join the two tables to determine what job an employee had on any date. We will use SQL to retrieve the data.</p>
</div>
<div id="create-a-test-sql-query" class="section level3">
<h3>Create a test SQL query</h3>
<p>Prior to creating our final SQL query with placeholder variables, it is a good idea to create a short test script with hard-coded conditions. Test scripts are easier to debug and help ensure your query is solid. Below is a sample SQL script that retrieves employee number 33066’s job on February 18, 2018.</p>
<pre class="sql"><code>SELECT
    &#39;2018-02-18&#39; AS &quot;Date of incident or notification&quot;,
    DH.employee_num,
    DH.desk_id,
    DJ.job_name
 FROM
    deskhistory DH,
    deskjob DJ  
 WHERE 
    DJ.desk_id = DH.desk_id
    AND DH.employee_num = 33066 
    AND DH.desk_id_start_date &lt;= DATE(&#39;2018-02-18&#39;) 
    AND DH.desk_id_end_date &lt;= DATE(&#39;2018-02-18&#39;) ;</code></pre>
<p>The above script is available online as <a href="https://raw.githubusercontent.com/harryahlas/sample-hr-database/master/scripts/mcdr_test.sql">mcdr_test.sql</a>. You can run it using the code below in R. You can see employee 33066 was an Analyst on 2/18/2018.</p>
<pre class="r"><code>test_sql &lt;- read_file(&quot;https://raw.githubusercontent.com/harryahlas/sample-hr-database/master/scripts/mcdr_test.sql&quot;)
test_df &lt;- dbGetQuery(con, test_sql)
test_df

  Date of incident or notification employee_num desk_id job_name
1                       2018-02-18        33066    1062  Analyst</code></pre>
</div>
<div id="add-placeholders-to-the-sql" class="section level3">
<h3>Add Placeholders to the SQL</h3>
<p>Now that we have a functional script that can pull one employee/date pair, we can scale the script by adding placeholders. The placeholders can be replaced with the multiple conditions that the client has provided.</p>
<p>In this request, we have two conditions that can change: <code>employee_num</code> and <code>Date of incident or notification</code>. In our new SQL script, let’s make these changes:</p>
<ul>
<li>Replace <code>employee_num</code> with <code>%EMP_ID%</code></li>
<li>Replace <code>Date of incident or notification</code> with <code>%DATE_ID%</code></li>
</ul>
<p>The new code looks like this:</p>
<pre class="sql"><code>SELECT
 DATE(&#39;%DATE_ID%&#39;) AS &quot;Date of incident or notification&quot;,
 DH.employee_num,
 DH.desk_id,
 DJ.job_name
 FROM
    deskhistory DH, 
    deskjob DJ  
 WHERE 
 DJ.desk_id = DH.desk_id
 AND DH.employee_num = %EMP_ID% 
 AND DH.desk_id_start_date &lt;= DATE(&#39;%DATE_ID%&#39;) 
 AND DH.desk_id_end_date &gt;= DATE(&#39;%DATE_ID%&#39;) ;</code></pre>
<p>So we now have a script, <a href="https://raw.githubusercontent.com/harryahlas/sample-hr-database/master/scripts/mcdr.sql">mcdr.sql</a>, that we can iterate through each employee/date pair the client has provided. We can replace <code>%EMP_ID%</code> and <code>%DATE_ID%</code> with the data in each row of the client’s worksheet. (Note the % signs in the placeholders are cosmetic and not required.)</p>
<p>Before we iterate through the entire client spreadsheet, let’s do a final test on one row of the client data to make sure the script with the placeholders works. Let’s start by importing mcdr.sql.</p>
<pre class="r"><code>mvdr_sql_placeholder &lt;- read_file(&quot;https://raw.githubusercontent.com/harryahlas/sample-hr-database/master/scripts/mcdr.sql&quot;)</code></pre>
<p>Next, we’ll use base R’s <code>gsub</code> function to fill the placeholders with the client’s data. For this example, we only want to pull data for a single employee/date pair, so we’ll subset row <code>[1]</code> of the data for the replacement arguments.</p>
<pre class="r"><code>mvdr_sql &lt;- mvdr_sql_placeholder %&gt;% 
  gsub(pattern = &#39;%EMP_ID%&#39;,
       replacement = input_data$`Employee Number`[1],
       x = .) %&gt;% 
  gsub(pattern = &#39;%DATE_ID%&#39;,
       replacement = input_data$`Date of incident or notification`[1],
       x = .)</code></pre>
<p>Now that the placeholders have been filled, we can retrieve the data.</p>
<pre class="r"><code>df_one_row &lt;- dbGetQuery(con, mvdr_sql)

df_one_row
  Date of incident or notification employee_num desk_id job_name
1                       2018-02-18        33066    1062  Analyst</code></pre>
<p>Great! The code is working and we are ready run through all the client data.</p>
</div>
<div id="ready-to-go---lets-iterate" class="section level3">
<h3>Ready to Go - Let’s Iterate</h3>
<p>We will use a for loop to retrieve the data. So one loop and retrieval for each row of client data. As I mentioned earlier in <a href="/post/2020-01-24-multi-condition-data-retrieval_files/2019-07-21-multi-condition-data-retrieval-challenges.html">my side post</a>, this is not the fastest way to pull data (and certainly not the only way) but it is a good hack to get around the system limitations that we can face.</p>
<p>To start, we will create an empty data frame called <code>df.</code> As we cycle through the client data, we’ll append our results to <code>df</code>.</p>
<pre class="r"><code>df &lt;- tibble()</code></pre>
<p>Next, we’ll start our for loop. Again, this will be one iteration per row. So i will be the same as the row number of the input data.</p>
<pre class="r"><code>for (i in 1:nrow(input_data)) {</code></pre>
<p>Once we are in the for loop, we will repeat the same code we used in the previous test run, with three changes:</p>
<ul>
<li>Add <code>[i]</code> to subset <code>input_data$'Employee Number'</code></li>
<li>Add <code>[i]</code> to subset <code>input_data$'Date of incident or notification'</code></li>
<li>Save the retrieved data to a temporary data frame called df_temp</li>
<li>Convert the <code>Date of incident or notification</code> field to text (SQLite is superfast but can be challenging when working with dates)</li>
</ul>
<pre class="r"><code># Replace placeholders with employee_num and date
  mvdr_sql &lt;- mvdr_sql_placeholder %&gt;% 
    gsub(pattern = &#39;%EMP_ID%&#39;,
         replacement = input_data$`Employee Number`[i],
         x = .) %&gt;% 
    gsub(pattern = &#39;%DATE_ID%&#39;,
         replacement = input_data$`Date of incident or notification`[i],
         x = .)
  
  # Retrieve data to temporary table
  df_temp &lt;- dbGetQuery(con, mvdr_sql)
  
  df_temp$`Date of incident or notification` &lt;- as.Date(df_temp$`Date of incident or notification`)</code></pre>
<p>The last piece of the loop will append the temporary data <code>df_temp</code> to the prior retrievals in <code>df.</code></p>
<pre class="r"><code>    df &lt;- bind_rows(df, df_temp)
}</code></pre>
<p>Running the code above will create a data frame with the information the client needs.</p>
</div>
<div id="export-to-excel" class="section level3">
<h3>Export to Excel</h3>
<p>To make things easy on the client, we’ll make our process look as seamless as possible. We’ll export an Excel file that looks nearly identical to what the client provided. We’ll start with our <code>input_data</code> data frame and join it to the new data from our for loop.</p>
<p>I try to add some realism to these examples when I can and a couple of those pieces are on display here. The client has asked for data that may not exist. They may be asking for employee information on a date that the employee was not with the company. Maybe the team member had terminated prior to that date. In those cases, our query retrieves NAs. We’ll use the <code>replace_na</code> function to add context for those NAs: <em>not with company at this time</em>. We will even format the job name and employee number columns to match what was on the client’s spreadsheet.</p>
<pre class="r"><code>output &lt;- input_data %&gt;% 
  left_join(df %&gt;% select(-desk_id),
            by = c(&quot;Date of incident or notification&quot;, 
                   &quot;Employee Number&quot; = &quot;employee_num&quot;)) %&gt;% 
  replace_na(list(job_name = &quot;not with company at this time&quot;)) %&gt;% 
  rename(`Job Name` = job_name)</code></pre>
<p>Last, we’ll use <em>openxlsx</em> to export to Excel. For this example we will export a single tab. Normally, I would include a second disclaimer tab, which I strongly recommend and discuss in another blog post called <a href="/post/use-r-to-add-a-data-disclaimer-to-an-excel-report/">Use R to add a Data Disclaimer to an Excel Report</a>.</p>
<pre class="r"><code>wb &lt;- createWorkbook()
addWorksheet(wb, &quot;HR data needed with output&quot;)
writeDataTable(wb, 1, output)
saveWorkbook(wb, &quot;Johnson litigation research with job_name.xlsx&quot;, TRUE)</code></pre>
<p>Here is the exported file:</p>
<div class="figure">
<img src="/post/2020-01-24-multi-condition-data-retrieval_files/client_output.gif" alt="Output for client" />
<p class="caption">Output for client</p>
</div>
</div>
<div id="final-thoughts" class="section level3">
<h3>Final Thoughts</h3>
<p>I didn’t share it here but I want to add I’ll usually include code to automatically log in/log out of the database periodically. This will prevent the connection from timing out. It is a must for the larger retrievals which can take several hours.</p>
<p>Hopefully your work environment is more flexible than mine and you are able to create temporary tables without having to worry about timeouts and avoid having to loop through retrievals as described here. But if you do face the same challenges I do then I hope this information has been helpful. I would enjoy hearing any feedback you have.</p>
</div>
</div>
